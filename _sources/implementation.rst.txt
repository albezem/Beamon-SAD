Implementation Details
**********************

This chapter include implementation details from database structure to UML class diagrams.
It should help develop an understanding of the project for newcomers.

The Database
============

The Database is implemented using SQLite3 in Python. Using SQLite database files as project files is quite convenient.
Therefore we will be referring to database files with project files.

Database Structure - Original Idea and It's Problems
-----------------------------------------------------

The following is an entity-relationship diagram (ER-Diagram) of the first sketch introduced in the bachelor thesis.

.. figure:: resources/diagrams/er_diagram_alpha.png

    ER-Diagram of the alpha release.

Some entities have composite attributes. For example, Links has attribute :math:`\vec{v}`, which practically
have to be divided up into v_x, v_y, and v_z.
*dof* represents which degree of freedom is locked/unlocked (0/1) on a node to save boundary conditions.
*edof* is element degree of freedom which consists of 12 integer numbers.

This design is problematic due to the following reasons:

#. Models should be parent of Nodes and not of Elements. If Models are defined only over Elements, all nodes that are not connected to any elements will be excluded from all models.
#. Visualizer settings should be child from Models.
#. Simulation results have no entities.
#. Names are to be renamed according to the naming convention. Also Links should be named Elements.

After solving the above issues and modeling the database in `DataGrip <https://www.jetbrains.com/datagrip/>`_ the database
will be more normalized.

The following diagram illustrates the modified version in an EER-Diagram.
The central table *model* is root of most other tables (except *profile* and *sqlite_master*).
For each model there is *setting* and *node*. This way *node*
plays a central role in identifying models structure. That's because everything else in a structure, ex. *element*,
depends on *node* to be defined.

*node_result* and *e_result* are children of *node* and *element* respectively. All foreign keys of all tables except
*profile_id* in *element* have cascade delete option. *profile_id* in *element* have Null on delete option because
elements still exist if there are no element properties defined. Those elements will be excluded from simulation easily
as well as nodes with no elements attached to them.

.. figure:: resources/diagrams/EER-Diagramm-Beta.png

SQLite Queries
--------------
The following sql query shows how to pass parameters to an sql query.
cur is connection object cursor.

.. code-block:: python

    import sqlite3
    conn = sqlite3.connect("path_to_database")
    cur = conn.cursor()
    cur.execute('SELECT id FROM Nodes WHERE x={x} and y={y} and z={z};'.format(x=0, y=0.1, z=-1))

Another way of passing parameters to sql queries is using the tuple params.

.. code-block:: python

    conn = sqlite3.connect("path_to_database")
    cur = conn.cursor()
    params = (0, 0.1, -1)
    cur.execute('SELECT id FROM Nodes WHERE x={?} and y={?} and z={?};', params)

You can also obtain panda Dataframes using sql queries. It is very convenient especially when using QTableViews to show
data tables.

.. code-block:: python

    conn = sqlite3.connect("path_to_database")
    import pandas.io.sql as sql
    sql.read_sql("""SELECT E, G, A, Iy, Iz, kv, k from Profile""", conn)

Problems with SQL Queries
-------------------------

The Database class is heavily dependent on underlying database design. This is problematic and could cause high costs and efficiency problems in the future.  Each change in the Database causes a chain of changes in SQL Queries.
I tried to use some design patterns to solve this issue.

Using Command in association with Memento resulted in a too complex design that solved some future issues but not the dependency problem.
Memento pattern helps saving the state of the database on each change. This way undo/redo implementation will be possible.
Command pattern could help making all commands the database saved in separate classes. This way each command has it's
own responsibility and decouple the database from the business logic.

The following diagram illustrates this approach.

.. figure:: resources/diagrams/Command_Memento.*

Invoker Class is responsible for firing the execution method of each command. A history of commands can be saved in a stack to record each change to the database and undo those changes when necessary.
This way the business logic of the original database Class is split between invoker and commands. But this will result in too many command classes.

A different Design could solve this problem. I made For each entity in the database a class using the interface Table and used it with the Command pattern (see diagram below). This way only Tables know how to use commands and only commands know how to access the database. But this is also problematic because Tables are very dependent. Changing one Table could cause a cascade of changes in other tables.

.. figure:: resources/diagrams/Database_System_v1.*

Approaching this problem from a different angle resulted in using an ORM-Solution. ORM stands for Object Relational Mapping and is intended to tackle a common issue called `Object-relational impedance mismatch <https://en.wikipedia.org/wiki/Object%E2%80%93relational_impedance_mismatch>`_.
The following design illustrates how this could be implemented.

.. figure:: resources/diagrams/Database_ORM.*




Reading Geometry Files Efficiently
-----------------------------------

Geometry files are, for modifiability purposes, text files with ASCII characters.
Reading large text files into SQLite database could cause run-time problems.
*import_text* method in *Database* class avoids those problems by firstly reading the text file in a buffered CSV file,
which will be transformed into pandas dataframe, which is imported eventually into the database efficiently.

The following activity diagram summarizes the steps taken in *import_text* to import geometry files.

.. figure:: resources/diagrams/activity_import_text.png

    UML activity diagram showing steps to import geometry files in activity import_text.

PySide2 or PyQt5
================

PySid2 and PyQt5 have almost the same api.
But it is worth mentioning that using PyQt5 is more beneficial in the long run.
PySide development lagged behind PyQt and PySide2 supports only Linux and MacOs Platforms.
On the Other hand PySide have very convenient Libraries for 3D animations that PyQt5 dont have.

Eventually PyQt5 was chosen due to major popularity and community support.

Package vs. Executable
======================

Running Beamon as a package is not much challenging as an Executable that has been securely compressed using
e.g. PyInstaller (among other).

In some cases you need to differentiate between the two situations.
Some dependencies have to be formatted first before they get used. For example all .ui files will be formatted
using pyuic5 from xml to python at every run in the main script. This will prevent mistakes like forgetting
to update the user interface that is being used after modification.
In the Executable version of the program this is no longer needed. The program will be in a frozen state and there
are no updates to any files anymore.

For this reason there are two main scripts for each of the program versions
**__main__.py** for Beamon as a package and **__main.py** for Beamon as an executable.

**__main.py** has no formatting commands whereas **__main__.py** uses pyuic5 module to format local files like .ui and
.rst


Class Structure (alpha release)
===============================

The following class diagram shows the whole class structure in Beamon project.

.. figure:: resources/diagrams/class_complex.*

    UML class diagram showing Beamon project structure.

There are two main scripts *__main__* and *__main* that instantiate the application.
*__main is for executables and does not contain formatting instructions. Both main scripts are connected to the *Main*
GUI class.

*Main* resides in the *ui* package, which contains everything related to the user interface.
As you can see *Main* inherits from *QMainWindow*, which is a single tone PyQt5 class.

*VisualizerMainForm* class is responsible for visualization. It contains *PyVistaWidget* which is the visualization
component based on PyVista and should therefore inherit from *QtInteractor*.
Furthermore, the visualizer can call helper dialogs like *GridSettingsMainForm* to control grid settings.

*BeamSizeMainForm* class can be called from *Main*. BeamSize is an expansion of the basic functionality of Beamon and
should therefore reside in the *expansions* package. *BeamSizeMainform* contains a PyQtGraph plot widget. *PlotWidget*
should therefore inherit from *QGraphicsView*.

*QDockWidget* can be triggered from *Main* and contains a widget that could be dynamically changed.

*IntroMainForm* contains a web browser that shows this documentation in PDF-format.

Inside *tables* package you will find classes that follow the model-view-controller design pattern. *TableMainForm*
contains the view, which is QTableView. *InLineEditDelegate* is the controller. All models like *NodeTableModel* inherit
from *QAbstractTableModel*.

*LoadingMainForm* is responsible for triggering the simulation with a dedicated thread *Worker* that runs the simulation
in the background.

*ProjectBrowserMainForm* is an overview of all Models and have a table with a view from *QTableView* that uses the model
*ModelsTableModel*. This UI calls *LoadProjectMainForm* that triggers the loading process in the background using a
thread.

Applied and Suitable Design Patterns
=====================================

+--------------------------------------------------------------------------------------------------------+
| Problem: Multiple table forms can be displayed in the table widget. Each table has its business logic. |
+========================================================================================================+
| Solution: Implement a Strategy pattern to switch tables dynamically.                                   |
+--------------------------------------------------------------------------------------------------------+

.. figure:: resources/diagrams/TableStrategy.*

+--------------------------------------------------------------------------------------------------------+
| Problem: Too many UI classes for tables causing duplicate code parts. Table classes are also dependent |
| on the calling class.                                                                                  |
+========================================================================================================+
| Solution: Implement the MVC pattern separating business logic into models, views, and controllers.     |
+--------------------------------------------------------------------------------------------------------+

.. figure:: resources/diagrams/TableMVC.*

The following design pattern could be used and has not yet been implemented.

+--------------------------------------------------------------------------------------------------------+
| Database imports and exports data in different formats using slightly different algorithms.            |
| This causes duplicate code parts and a dependency problem                                              |
+========================================================================================================+
| Solution: Implement the Template Method design pattern to avoid code duplication by pulling            |
| the duplicate code into a superclass.                                                                  |
+--------------------------------------------------------------------------------------------------------+

.. figure:: resources/diagrams/ExportTemplateMethod.*


How The UI Is Built
====================

As can be seen in the figure below, the *.ui* file (which is an XML file) is made using the Qt Designer.
Let's assume we are formatting the main UI, which is *main.ui*.
This file can be formatted to a python class, *Ui_MainWindow*, using the pyqt5ac package. Class *Main* is
then connected to *Ui_MainWindow* and has all the backend functionality of the main UI.

.. figure:: resources/diagrams/qt.png

    Diagram explaining how an exemplary UI class is built.

Main class should be initiated like this.

.. code-block:: python

    class Main(QMainWindow):
        __init__(self):
            super().__init__()
            self.ui = Ui_MainWindow()
            self.ui.setupUi(self)


The Simulation
==============

.. figure:: resources/diagrams/SimulationSteps.*

    The Simulation is summarized in four steps. Calculating the stiffness matrix for each element, assembling
    element stiffness matrices in a global stiffness matrix, solving the systems of equations, and calculating
    results.

The following diagram shows how the simulation in Beamon is implemented. Three parts are involved in the Simulation,
*Database*, *Core* and *CALFEM*. Each part has it's own responsibility. *Database* is responsible for obtaining and
saving data. *Core* is responsible for the calculations implemented in Beamon. *CALFEM* is the Calfem-Python Package
which is responsible for the most complex calculations.

.. figure:: resources/diagrams/activity_simulation.jpg

    UML activity diagram showing static simulation steps.




